# 代码随想录算法训练营74期|链表part02 交换节点、链表相交、环形链表

| 题目     | Leetcode地址 |
| ----------- | ----------- |
| 24.两两交换链表中的节点| [力扣题目链接](https://leetcode.cn/problems/swap-nodes-in-pairs/)      |
|19.删除链表的倒数第N个节点| [力扣题目链接](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)        |
|160.相交链表|[力扣题目链接](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)   |
|142.环形链表|||[力扣题目链接](https://leetcode.cn/problems/linked-list-cycle-ii/)   |


19. 删除链表的倒数第 N 个结点：删除链表的倒数第 N 个结点。这道题需要注意的是，删除节点需要找到待删除节点的前一个节点，所以需要一个虚拟头节点。这里如果要一遍遍历删除，就需要用到双指针的思想。让快指针先走n步，然后慢指针开始走，这样快慢指针间隔N个节点，当快指针到达链表尾部时，慢指针指向的就是待删除节点。具体的边界感需要自己想一下。
24. 两两交换链表中的节点：两两交换链表中的节点。还是模拟的方法，不多赘述
## 首先是链表相交
这道题的思路是，先遍历两个链表，得到两个链表的长度，然后让长的链表先走，直到两个链表的长度相等，然后再一起走，直到两个链表相等。
为了尽量的减少代码的重复度，可以默认A链表是最长的，在开始前进行交换，始终保证A链表的长度大于等于B链表。
**在判断时需要注意，判断的是节点是否相等，而不是节点的值是否相等**。
还有就是，遍历完求长度后，记得重新初始化指针
## 环形链表
- 首先需要解决的是，**如何判断链表是否有环？**：
     以操场跑步为例，操场是一个环，那么快的人永远会追上慢的人（套圈）。所以，可以设置一个快慢指针，快指针每次走两步，慢指针每次走一步，如果快指针追上了慢指针，那么就说明链表有环。
- 其次是，**如何判断链表的环的入口？**：
   这里需要用到一些简单的数学知识：
   利用快指针是慢指针的两倍去构造等式
   慢节点走过的路程为x + y.为什么不是x + n*(y + z) + y呢？因为，如果慢节点能走过一圈，那么快指针应该已经走完了两圈，在这之前，两个指针早就相遇了，所以，慢节点不会走完一圈，所以，慢节点走过的路程为x + y.<br>
   快节点走过的路程为x + n*(y + z) + y 
   由等式关系可知，快指针的路程是慢指针的两倍。
   所以，x + n*(y + z) + y = 2*(x + y)
   化简得：x = (n - 1)*(y + z) + z
   这里的n是一个常数，所以，x = z
   所以，当快慢指针相遇时，将快指针重新指向头节点，然后快慢指针同时走，当快慢指针相遇时，相遇的节点就是环的入口。

# 链表总结：

链表的种类主要为：单链表，双链表，循环链表
链表的存储方式：链表的节点在内存中是分散存储的，通过指针连在一起。
链表是如何进行增删改查的。
数组和链表在不同场景下的性能分析。
对于链表的题目，最大的困惑可能就是 什么使用用虚拟头结点，什么时候不用虚拟头结点？ 
一般涉及到 **增删改操作**，用虚拟头结点都会方便很多， 如果只能查的话，用不用虚拟头结点都差不多。 

详见[链表总结](https://programmercarl.com/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93%E7%AF%87.html#%E6%80%BB%E7%BB%93)
